<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>How it works · ConservativeRegridding.jl</title><meta name="title" content="How it works · ConservativeRegridding.jl"/><meta property="og:title" content="How it works · ConservativeRegridding.jl"/><meta property="twitter:title" content="How it works · ConservativeRegridding.jl"/><meta name="description" content="Documentation for ConservativeRegridding.jl."/><meta property="og:description" content="Documentation for ConservativeRegridding.jl."/><meta property="twitter:description" content="Documentation for ConservativeRegridding.jl."/><meta property="og:url" content="https://juliageo.org/ConservativeRegridding.jl/stable/how_it_works/"/><meta property="twitter:url" content="https://juliageo.org/ConservativeRegridding.jl/stable/how_it_works/"/><link rel="canonical" href="https://juliageo.org/ConservativeRegridding.jl/stable/how_it_works/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">ConservativeRegridding.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>How it works</a><ul class="internal"><li><a class="tocitem" href="#The-high-level-picture"><span>The high-level picture</span></a></li><li><a class="tocitem" href="#Step-1:-Converting-grids-to-trees"><span>Step 1: Converting grids to trees</span></a></li><li><a class="tocitem" href="#Step-2:-The-dual-tree-query"><span>Step 2: The dual tree query</span></a></li><li><a class="tocitem" href="#Step-3:-Computing-intersection-weights-(first-order-conservative)"><span>Step 3: Computing intersection weights (first-order conservative)</span></a></li><li><a class="tocitem" href="#Putting-it-together"><span>Putting it together</span></a></li><li><a class="tocitem" href="#Tips-for-users"><span>Tips for users</span></a></li></ul></li><li><span class="tocitem">Interfaces</span><ul><li><a class="tocitem" href="../interfaces/trees/">Tree Interface</a></li><li><a class="tocitem" href="../interfaces/regrid/">Regridding Interface</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>How it works</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>How it works</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaGeo/ConservativeRegridding.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaGeo/ConservativeRegridding.jl/blob/main/docs/src/how_it_works.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="How-it-works"><a class="docs-heading-anchor" href="#How-it-works">How it works</a><a id="How-it-works-1"></a><a class="docs-heading-anchor-permalink" href="#How-it-works" title="Permalink"></a></h1><p>This guide explains what happens under the hood when you create a <code>Regridder</code> and use it to regrid data. Understanding these internals can help you make better decisions about grid representations and debug unexpected behavior.</p><h2 id="The-high-level-picture"><a class="docs-heading-anchor" href="#The-high-level-picture">The high-level picture</a><a id="The-high-level-picture-1"></a><a class="docs-heading-anchor-permalink" href="#The-high-level-picture" title="Permalink"></a></h2><p>When you call <code>Regridder(dst, src)</code>, three main things happen:</p><ol><li>Tree construction: Both grids are converted into spatial tree structures</li><li>Dual tree query: The trees are walked simultaneously, aggressively pruning branches that can&#39;t possibly intersect</li><li>Weight computation: For the surviving polygon pairs, compute some weight metric for each, and encode that into some operator (usually a sparse matrix).</li></ol><p>Step 3 is the one that will change the most across algorithms.  First-order conservative regridding (the simplest) would use the intersection areas directly as weights. But other algorithms like second-order conservative regridding, bilinear, etc. will use different weight metrics.</p><p>Let&#39;s explore each step.</p><h2 id="Step-1:-Converting-grids-to-trees"><a class="docs-heading-anchor" href="#Step-1:-Converting-grids-to-trees">Step 1: Converting grids to trees</a><a id="Step-1:-Converting-grids-to-trees-1"></a><a class="docs-heading-anchor-permalink" href="#Step-1:-Converting-grids-to-trees" title="Permalink"></a></h2><p>The first thing ConservativeRegridding does is call <code>Trees.treeify(manifold, grid)</code> on both the source and destination grids. This function takes whatever grid representation you provide and wraps it in a spatial tree structure.</p><h3 id="Why-trees?"><a class="docs-heading-anchor" href="#Why-trees?">Why trees?</a><a id="Why-trees?-1"></a><a class="docs-heading-anchor-permalink" href="#Why-trees?" title="Permalink"></a></h3><p>A naive approach to finding intersecting polygons would check every source cell against every destination cell — that&#39;s <code>O(n × m)</code> comparisons. For a 1000×1000 grid against another 1000×1000 grid, that&#39;s a trillion polygon intersection checks.</p><p>Trees let us do much better. By organizing polygons hierarchically (grouping nearby cells together), we can quickly reject entire regions of one grid that can&#39;t possibly intersect with a region of the other grid.  </p><h3 id="How-treeify-works"><a class="docs-heading-anchor" href="#How-treeify-works">How treeify works</a><a id="How-treeify-works-1"></a><a class="docs-heading-anchor-permalink" href="#How-treeify-works" title="Permalink"></a></h3><p>The <code>treeify</code> function examines your input and chooses an appropriate representation:</p><table><tr><th style="text-align: right">Input type</th><th style="text-align: right">Tree structure</th><th style="text-align: right">Notes</th></tr><tr><td style="text-align: right">Matrix of polygons</td><td style="text-align: right"><code>ExplicitPolygonGrid</code> → <code>TopDownQuadtreeCursor</code></td><td style="text-align: right">Most flexible, least optimized</td></tr><tr><td style="text-align: right">Matrix of corner points</td><td style="text-align: right"><code>CellBasedGrid</code> → <code>TopDownQuadtreeCursor</code></td><td style="text-align: right">Builds polygons on-the-fly from corners</td></tr><tr><td style="text-align: right">Tuple of 1D coordinate vectors</td><td style="text-align: right"><code>RegularGrid</code> → <code>TopDownQuadtreeCursor</code></td><td style="text-align: right">For regular lon/lat grids</td></tr><tr><td style="text-align: right">Iterable of polygons</td><td style="text-align: right"><code>FlatNoTree</code></td><td style="text-align: right">No spatial indexing, used for small grids</td></tr><tr><td style="text-align: right">Existing spatial tree</td><td style="text-align: right">Pass-through</td><td style="text-align: right">If it already implements the tree interface</td></tr></table><p>A key abstraction is <code>AbstractCurvilinearGrid</code>, which represents grids where spatial neighbors in the grid are also neighbors in the underlying matrix.  This structure enables efficient quadtree decomposition and encodes the structure of the grid in an efficient way.   Other grids will have different structures, for example Healpix and other hierarchical <a href="https://en.wikipedia.org/wiki/Discrete_global_grid">global grids</a> -  which you can use here also.</p><h3 id="Grid-representations-encode-knowledge"><a class="docs-heading-anchor" href="#Grid-representations-encode-knowledge">Grid representations encode knowledge</a><a id="Grid-representations-encode-knowledge-1"></a><a class="docs-heading-anchor-permalink" href="#Grid-representations-encode-knowledge" title="Permalink"></a></h3><p>Different grid representations encode different facts that can be exploited for performance:</p><ul><li><p><strong><code>RegularGrid</code></strong>: Knows the grid is axis-aligned and regular, so computing bounding boxes for any region is <code>O(1)</code> — just index into the coordinate vectors.</p></li><li><p><strong><code>CellBasedGrid</code></strong>: Stores corner vertices rather than full polygons. Bounding boxes are computed from the corner points of a region, avoiding polygon traversal.</p></li><li><p><strong><code>ExplicitPolygonGrid</code></strong>: The most general case. Must iterate through polygons to compute bounding boxes, but works with any polygon shape.</p></li></ul><p>The <code>TopDownQuadtreeCursor</code> wraps any of these grid types and provides the tree traversal interface. It tracks which rectangular region of the grid it currently represents and can split that region into four quadrants.</p><h2 id="Step-2:-The-dual-tree-query"><a class="docs-heading-anchor" href="#Step-2:-The-dual-tree-query">Step 2: The dual tree query</a><a id="Step-2:-The-dual-tree-query-1"></a><a class="docs-heading-anchor-permalink" href="#Step-2:-The-dual-tree-query" title="Permalink"></a></h2><p>Once both grids have tree representations, ConservativeRegridding performs a <em>dual depth-first search</em>. This is the key algorithm that makes conservative regridding tractable for large grids.</p><h3 id="The-core-idea"><a class="docs-heading-anchor" href="#The-core-idea">The core idea</a><a id="The-core-idea-1"></a><a class="docs-heading-anchor-permalink" href="#The-core-idea" title="Permalink"></a></h3><p>The algorithm walks down both trees simultaneously. At each step, it has a node from the source tree and a node from the destination tree. Each node represents some region of its respective grid and has an <em>extent</em> (bounding box or spherical cap) that encloses all polygons in that region.</p><p>The question at each step is: <strong>can any polygon in this source region possibly intersect any polygon in this destination region?</strong></p><p>If the extents don&#39;t intersect, the answer is definitively <em>no</em> — and we can prune both branches entirely. This single check eliminates potentially millions of polygon pairs from consideration.</p><p>If the extents <em>do</em> intersect, we recurse: we check each child of the source node against each child of the destination node. This continues until we reach leaf nodes, at which point we record the polygon index pairs for later intersection computation.</p><h3 id="Pruning-in-action"><a class="docs-heading-anchor" href="#Pruning-in-action">Pruning in action</a><a id="Pruning-in-action-1"></a><a class="docs-heading-anchor-permalink" href="#Pruning-in-action" title="Permalink"></a></h3><p>Consider two 100×100 grids that only overlap in a corner:</p><pre><code class="nohighlight hljs">Source grid
┌──────────┐
│          │
│          │
│       ┌──┼──────────┐
└───────┼──┘          │
        │↖ overlap    │
        │             │
        │  Dest grid  │
        └─────────────┘</code></pre><p>At the top level, both trees represent their entire grids. The extents intersect (there is overlap), so we recurse.</p><p>Each tree splits into four quadrants. The source&#39;s top-left, top-right, and bottom-left quadrants don&#39;t intersect with any destination quadrant. Only the source&#39;s bottom-right quadrant intersects with the destination&#39;s top-left quadrant. We&#39;ve just eliminated 75% of the source grid and 75% of the destination grid from consideration.</p><p>This pruning compounds at each level. If the overlap region is small, the algorithm quickly narrows down to just the relevant cells.</p><h3 id="Multithreading"><a class="docs-heading-anchor" href="#Multithreading">Multithreading</a><a id="Multithreading-1"></a><a class="docs-heading-anchor-permalink" href="#Multithreading" title="Permalink"></a></h3><p>For large grids, the dual tree query can spawn multiple threads. Once nodes are small enough (determined by an area criterion), each thread independently performs the depth-first search on its subtree pair.</p><p>The result is a list of <code>(source_index, destination_index)</code> pairs — the candidate polygon pairs that might actually intersect.</p><h2 id="Step-3:-Computing-intersection-weights-(first-order-conservative)"><a class="docs-heading-anchor" href="#Step-3:-Computing-intersection-weights-(first-order-conservative)">Step 3: Computing intersection weights (first-order conservative)</a><a id="Step-3:-Computing-intersection-weights-(first-order-conservative)-1"></a><a class="docs-heading-anchor-permalink" href="#Step-3:-Computing-intersection-weights-(first-order-conservative)" title="Permalink"></a></h2><p>With the candidate pairs identified, we now compute the actual intersection areas. For each pair:</p><ol><li>Retrieve the source and destination polygons using <code>getcell</code></li><li>Compute their geometric intersection</li><li>Calculate the area of that intersection</li></ol><h3 id="Manifold-aware-algorithms"><a class="docs-heading-anchor" href="#Manifold-aware-algorithms">Manifold-aware algorithms</a><a id="Manifold-aware-algorithms-1"></a><a class="docs-heading-anchor-permalink" href="#Manifold-aware-algorithms" title="Permalink"></a></h3><p>The intersection algorithm depends on the manifold:</p><ul><li><strong>Planar</strong>: Uses the Foster-Hormann clipping algorithm, which handles arbitrary (including non-convex) polygons</li><li><strong>Spherical</strong>: Uses Sutherland-Hodgman clipping specialized for convex polygons on the unit sphere</li></ul><p>Areas are computed in the appropriate geometry — Cartesian area for planar, spherical excess for spherical manifolds.</p><h3 id="Parallel-computation"><a class="docs-heading-anchor" href="#Parallel-computation">Parallel computation</a><a id="Parallel-computation-1"></a><a class="docs-heading-anchor-permalink" href="#Parallel-computation" title="Permalink"></a></h3><p>The list of candidate pairs is partitioned across threads. Each thread independently computes intersection areas for its partition, then results are merged into a sparse matrix.</p><h3 id="The-sparse-matrix"><a class="docs-heading-anchor" href="#The-sparse-matrix">The sparse matrix</a><a id="The-sparse-matrix-1"></a><a class="docs-heading-anchor-permalink" href="#The-sparse-matrix" title="Permalink"></a></h3><p>The final output is a sparse matrix <code>A</code> where <code>A[i,j]</code> is the intersection area between destination cell <code>i</code> and source cell <code>j</code>. Most entries are zero (cells don&#39;t intersect), which is why sparse storage is essential.</p><p>This matrix, combined with cell areas, is everything needed for conservative regridding:</p><pre><code class="nohighlight hljs">destination_field = (A * source_field) ./ destination_areas</code></pre><h2 id="Putting-it-together"><a class="docs-heading-anchor" href="#Putting-it-together">Putting it together</a><a id="Putting-it-together-1"></a><a class="docs-heading-anchor-permalink" href="#Putting-it-together" title="Permalink"></a></h2><p>Here&#39;s the full flow when you call <code>Regridder(dst, src)</code>:</p><pre><code class="nohighlight hljs">dst, src
    │
    ▼ treeify()
dst_tree, src_tree
    │
    ▼ dual_depth_first_search()
candidate_pairs: [(i₁,j₁), (i₂,j₂), ...]
    │
    ▼ compute_intersection_areas() [parallel]
(row_indices, col_indices, areas)
    │
    ▼ sparse()
intersection_matrix A
    │
    ▼ + cell areas
Regridder</code></pre><h2 id="Tips-for-users"><a class="docs-heading-anchor" href="#Tips-for-users">Tips for users</a><a id="Tips-for-users-1"></a><a class="docs-heading-anchor-permalink" href="#Tips-for-users" title="Permalink"></a></h2><p><strong>Reuse the Regridder</strong>: Building a <code>Regridder</code> is expensive; using it is cheap. If you&#39;re regridding multiple fields between the same grids, build the regridder once and reuse it.</p><p><strong>Let treeify do its job</strong>: In most cases, you can pass your grid directly to <code>Regridder</code> and <code>Trees.treeify</code> will choose a reasonable representation. You as the owner of a grid type only need to implement <code>Trees.treeify</code> correctly.</p><p><strong>Understand the cost model</strong>: The expensive part is usually the polygon intersections, not the tree query. If regridding is slow, it may be because many polygon pairs actually intersect, not because the tree traversal is inefficient.  To be sure of this, you can time how long it takes to run e.g.</p><pre><code class="language-julia hljs">import GeometryOps as GO

tree1 = ...
tree2 = ...

idxs = Tuple{Int, Int}[]
@time GO.SpatialTreeInterface.dual_depth_first_search(
    GO.UnitSpherical._intersects, tree1, tree2
    ) do i1, i2
    push!(idxs, (i1, i2))
end</code></pre><p>and see how long that takes (this is singlethreaded).  You can try the same for `ConservativeRegridding.multi</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../interfaces/trees/">Tree Interface »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Friday 23 January 2026 19:54">Friday 23 January 2026</span>. Using Julia version 1.12.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
