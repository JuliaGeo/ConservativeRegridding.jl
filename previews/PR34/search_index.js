var documenterSearchIndex = {"docs":
[{"location":"#ConservativeRegridding.jl","page":"Home","title":"ConservativeRegridding.jl","text":"ConservativeRegridding.jl provides functionality to regrid between two arbitrary grids. A grid is a tessellation of a space into polygons (or grid cells), each with an associated value. Data on a grid is referred to as a field, whereas the grid itself defines the tessellation.\n\nRegridding is performed conservatively, meaning the area-weighted mean is preserved. This is achieved by computing the intersection areas between all combinations of grid cells from the source and destination grids. These intersection areas provide the weights for averaging from neighboring cells.","category":"section"},{"location":"#Quick-Start:-SpeedyWeather-Grid-Transfer","page":"Home","title":"Quick Start: SpeedyWeather Grid Transfer","text":"Here's an example of regridding between two different geodesic grids from SpeedyWeather.jl:\n\nusing SpeedyWeather\nusing ConservativeRegridding\n\nimport GeoInterface as GI\nimport GeometryOps as GO\n\n# Create random data on two different geodesic grid types\nfield1 = rand(OctaHEALPixGrid, 4)\nfield2 = rand(OctaminimalGaussianGrid, 4)\n\n# Get the polygon vertices for each grid (each column is a polygon as (lon, lat) tuples)\n# The Regridder constructor handles wrapping these as GeoInterface polygons and\n# fixing antimeridian crossings internally\nverts1 = RingGrids.get_gridcell_polygons(field1.grid)\nverts2 = RingGrids.get_gridcell_polygons(field2.grid)\n\n# Build the regridder (precomputes intersection areas)\nR = ConservativeRegridding.Regridder(verts1, verts2)\n\n# Regrid from field2 to field1\nConservativeRegridding.regrid!(field1, R, field2)\n\n# Regrid in the reverse direction using the transpose\nConservativeRegridding.regrid!(field2, transpose(R), field1)\n\nThe key advantage is that the Regridder only needs to be constructed once. After that, both forward regridding (via R) and backward regridding (via transpose(R)) can be performed efficiently without recomputing intersection areas.","category":"section"},{"location":"#Mathematics-of-Regridding","page":"Home","title":"Mathematics of Regridding","text":"","category":"section"},{"location":"#The-Intersection-Area-Matrix","page":"Home","title":"The Intersection Area Matrix","text":"Conservative regridding is built around a matrix A of intersection areas between source and destination grid cells. For a source grid with m cells and a destination grid with n cells, the matrix A is n times m, where each entry A_ij represents the area of intersection between destination cell i and source cell j.\n\nThe algorithm uses an efficient spatial tree structure (STRtree) to compute only the non-zero intersections, avoiding the O(nm) cost of checking all cell pairs.","category":"section"},{"location":"#Forward-Regridding","page":"Home","title":"Forward Regridding","text":"Let s be a vector of field values on the source grid and d the destination field values. The forward regrid operation computes:\n\nd_i = fracsum_j A_ij s_ja^d_i\n\nor in matrix form:\n\nd = fracA sa^d\n\nwhere a^d_i is the area of destination cell i, and the division is element-wise. The matrix-vector product As yields values weighted by intersection areas, and the division by a^d normalizes to obtain the regridded field values.","category":"section"},{"location":"#Backward-Regridding","page":"Home","title":"Backward Regridding","text":"The same intersection matrix A can be reused for backward regridding by transposing it:\n\ntildes = fracA^T da^s\n\nwhere a^s_j is the area of source cell j. The tilde on tildes emphasizes that the round-trip operation s to d to tildes does not recover the original field exactly—conservative regridding preserves the mean but generally reduces variance.","category":"section"},{"location":"#Conservation-Property","page":"Home","title":"Conservation Property","text":"Conservative regridding preserves the area-weighted mean:\n\nfracsum_i d_i a^d_isum_i a^d_i = fracsum_j s_j a^s_jsum_j a^s_j\n\nThis property holds when both grids cover the same total area. The areas can be computed from the regridder via row and column sums of A:\n\na^d_i = sum_j A_ij quad textand quad a^s_j = sum_i A_ij","category":"section"},{"location":"#Implementation-Details","page":"Home","title":"Implementation Details","text":"In ConservativeRegridding.jl:\n\nSparse storage: The intersection matrix A is stored as a sparse matrix since most grid cell pairs do not intersect.\nSTRtree acceleration: A Sort-Tile-Recursive tree enables efficient spatial queries to find intersecting cell pairs.\nGeometryOps integration: Polygon intersections and area calculations are handled by GeometryOps.jl.\n~Antimeridian handling: Polygons crossing the antimeridian are automatically fixed via GeometryOps.fix.~\nNormalization: By default, the intersection areas are normalized to improve numerical conditioning.","category":"section"},{"location":"#API-Reference","page":"Home","title":"API Reference","text":"","category":"section"},{"location":"#ConservativeRegridding.Regridder","page":"Home","title":"ConservativeRegridding.Regridder","text":"Regridder(\n    dst_vertices,\n    src_vertices;\n    normalize,\n    kwargs...\n) -> ConservativeRegridding.Regridder{W} where W<:(AbstractMatrix)\n\n\nReturn a Regridder that transfers data from src_field to dst_field.\n\nRegridder stores the intersection areas between The areas are computed by summing the regridder along the first and second dimensions as the regridder is a matrix of the intersection areas between each grid cell between the two grids. Additional kwargs are passed to the intersection_areas function.\n\n\n\n\n\n","category":"type"},{"location":"#ConservativeRegridding.regrid!","page":"Home","title":"ConservativeRegridding.regrid!","text":"regrid!(\n    dst_field,\n    regridder::ConservativeRegridding.Regridder,\n    src_field\n) -> Any\n\n\nRegrid data on src_field onto dst_field conservativly (mean-preserving) using the regridder matrix. dst_area is the area of each grid cell in dst_field and is used to normalize the result, if not provided, will recompute this from regridder. src_field and dst_field can be any n-dimensional array in which case it regridding of the 1st dimension is broadcast to additional dimensions.\n\nMathematics of regridding: if A are the intersection areas between the respective grids of the fields d (dst) and s (src), and aˢ and aᵈ are the areas of the source and destination grid cells, then d is computed via\n\nd = (A s)  aˢ \n\nNote that by construction,\n\n    aᵈ = sum(A 2)\n    aˢ = sum(A 1)\n\n\n\n\n\n","category":"function"}]
}
