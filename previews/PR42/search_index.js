var documenterSearchIndex = {"docs":
[{"location":"#ConservativeRegridding.jl","page":"Home","title":"ConservativeRegridding.jl","text":"ConservativeRegridding.jl provides functionality to regrid between two arbitrary grids. A grid is a tessellation of a space into polygons (or grid cells), each with an associated value. Data on a grid is referred to as a field, whereas the grid itself defines the tessellation.\n\nRegridding is performed conservatively, meaning the area-weighted mean is preserved. This is achieved by computing the intersection areas between all combinations of grid cells from the source and destination grids. These intersection areas provide the weights for averaging from neighboring cells.","category":"section"},{"location":"#Quick-Start:-SpeedyWeather-Grid-Transfer","page":"Home","title":"Quick Start: SpeedyWeather Grid Transfer","text":"Here's an example of regridding between two different geodesic grids from SpeedyWeather.jl:\n\nusing SpeedyWeather\nusing ConservativeRegridding\n\nimport GeoInterface as GI\nimport GeometryOps as GO\n\n# Create random data on two different geodesic grid types\nfield1 = rand(OctaHEALPixGrid, 4)\nfield2 = rand(OctaminimalGaussianGrid, 4)\n\n# Get the polygon vertices for each grid (each column is a polygon as (lon, lat) tuples)\n# The Regridder constructor handles wrapping these as GeoInterface polygons and\n# fixing antimeridian crossings internally\nverts1 = RingGrids.get_gridcell_polygons(field1.grid)\nverts2 = RingGrids.get_gridcell_polygons(field2.grid)\n\n# Build the regridder (precomputes intersection areas)\nR = ConservativeRegridding.Regridder(verts1, verts2)\n\n# Regrid from field2 to field1\nConservativeRegridding.regrid!(field1, R, field2)\n\n# Regrid in the reverse direction using the transpose\nConservativeRegridding.regrid!(field2, transpose(R), field1)\n\nThe key advantage is that the Regridder only needs to be constructed once. After that, both forward regridding (via R) and backward regridding (via transpose(R)) can be performed efficiently without recomputing intersection areas.","category":"section"},{"location":"#Mathematics-of-Regridding","page":"Home","title":"Mathematics of Regridding","text":"","category":"section"},{"location":"#The-Intersection-Area-Matrix","page":"Home","title":"The Intersection Area Matrix","text":"Conservative regridding is built around a matrix A of intersection areas between source and destination grid cells. For a source grid with m cells and a destination grid with n cells, the matrix A is n times m, where each entry A_ij represents the area of intersection between destination cell i and source cell j.\n\nThe algorithm uses an efficient spatial tree structure (STRtree) to compute only the non-zero intersections, avoiding the O(nm) cost of checking all cell pairs.","category":"section"},{"location":"#Forward-Regridding","page":"Home","title":"Forward Regridding","text":"Let s be a vector of field values on the source grid and d the destination field values. The forward regrid operation computes:\n\nd_i = fracsum_j A_ij s_ja^d_i\n\nor in matrix form:\n\nd = fracA sa^d\n\nwhere a^d_i is the area of destination cell i, and the division is element-wise. The matrix-vector product As yields values weighted by intersection areas, and the division by a^d normalizes to obtain the regridded field values.","category":"section"},{"location":"#Backward-Regridding","page":"Home","title":"Backward Regridding","text":"The same intersection matrix A can be reused for backward regridding by transposing it:\n\ntildes = fracA^T da^s\n\nwhere a^s_j is the area of source cell j. The tilde on tildes emphasizes that the round-trip operation s to d to tildes does not recover the original field exactly—conservative regridding preserves the mean but generally reduces variance.","category":"section"},{"location":"#Conservation-Property","page":"Home","title":"Conservation Property","text":"Conservative regridding preserves the area-weighted mean:\n\nfracsum_i d_i a^d_isum_i a^d_i = fracsum_j s_j a^s_jsum_j a^s_j\n\nThis property holds when both grids cover the same total area. The areas can be computed from the regridder via row and column sums of A:\n\na^d_i = sum_j A_ij quad textand quad a^s_j = sum_i A_ij","category":"section"},{"location":"#Implementation-Details","page":"Home","title":"Implementation Details","text":"In ConservativeRegridding.jl:\n\nSparse storage: The intersection matrix A is stored as a sparse matrix since most grid cell pairs do not intersect.\nSTRtree acceleration: A Sort-Tile-Recursive tree enables efficient spatial queries to find intersecting cell pairs.\nGeometryOps integration: Polygon intersections and area calculations are handled by GeometryOps.jl.\n~Antimeridian handling: Polygons crossing the antimeridian are automatically fixed via GeometryOps.fix.~\nNormalization: By default, the intersection areas are normalized to improve numerical conditioning.","category":"section"},{"location":"#API-Reference","page":"Home","title":"API Reference","text":"","category":"section"},{"location":"#ConservativeRegridding.regrid!","page":"Home","title":"ConservativeRegridding.regrid!","text":"regrid!(\n    dst_field::DenseVector,\n    regridder::ConservativeRegridding.Regridder,\n    src_field::DenseVector\n) -> DenseVector\n\n\nRegrid data on src_field onto dst_field conservativly (mean-preserving) using the regridder matrix. dst_area is the area of each grid cell in dst_field and is used to normalize the result, if not provided, will recompute this from regridder. src_field and dst_field can be any n-dimensional array in which case it regridding of the 1st dimension is broadcast to additional dimensions.\n\nMathematics of regridding: if A are the intersection areas between the respective grids of the fields d (dst) and s (src), and aˢ and aᵈ are the areas of the source and destination grid cells, then d is computed via\n\nd = (A s)  aˢ \n\nNote that by construction,\n\n    aᵈ = sum(A 2)\n    aˢ = sum(A 1)\n\n\n\n\n\n","category":"function"},{"location":"how_it_works/#How-it-works","page":"How it works","title":"How it works","text":"This guide explains what happens under the hood when you create a Regridder and use it to regrid data. Understanding these internals can help you make better decisions about grid representations and debug unexpected behavior.","category":"section"},{"location":"how_it_works/#The-high-level-picture","page":"How it works","title":"The high-level picture","text":"When you call Regridder(dst, src), three main things happen:\n\nTree construction: Both grids are converted into spatial tree structures\nDual tree query: The trees are walked simultaneously, aggressively pruning branches that can't possibly intersect\nWeight computation: For the surviving polygon pairs, compute some weight metric for each, and encode that into some operator (usually a sparse matrix).\n\nStep 3 is the one that will change the most across algorithms.  First-order conservative regridding (the simplest) would use the intersection areas directly as weights. But other algorithms like second-order conservative regridding, bilinear, etc. will use different weight metrics.\n\nLet's explore each step.","category":"section"},{"location":"how_it_works/#Step-1:-Converting-grids-to-trees","page":"How it works","title":"Step 1: Converting grids to trees","text":"The first thing ConservativeRegridding does is call Trees.treeify(manifold, grid) on both the source and destination grids. This function takes whatever grid representation you provide and wraps it in a spatial tree structure.","category":"section"},{"location":"how_it_works/#Why-trees?","page":"How it works","title":"Why trees?","text":"A naive approach to finding intersecting polygons would check every source cell against every destination cell — that's O(n × m) comparisons. For a 1000×1000 grid against another 1000×1000 grid, that's a trillion polygon intersection checks.\n\nTrees let us do much better. By organizing polygons hierarchically (grouping nearby cells together), we can quickly reject entire regions of one grid that can't possibly intersect with a region of the other grid.  ","category":"section"},{"location":"how_it_works/#How-treeify-works","page":"How it works","title":"How treeify works","text":"The treeify function examines your input and chooses an appropriate representation:\n\nInput type Tree structure Notes\nMatrix of polygons ExplicitPolygonGrid → TopDownQuadtreeCursor Most flexible, least optimized\nMatrix of corner points CellBasedGrid → TopDownQuadtreeCursor Builds polygons on-the-fly from corners\nTuple of 1D coordinate vectors RegularGrid → TopDownQuadtreeCursor For regular lon/lat grids\nIterable of polygons FlatNoTree No spatial indexing, used for small grids\nExisting spatial tree Pass-through If it already implements the tree interface\n\nA key abstraction is AbstractCurvilinearGrid, which represents grids where spatial neighbors in the grid are also neighbors in the underlying matrix.  This structure enables efficient quadtree decomposition and encodes the structure of the grid in an efficient way.   Other grids will have different structures, for example Healpix and other hierarchical global grids -  which you can use here also.","category":"section"},{"location":"how_it_works/#Grid-representations-encode-knowledge","page":"How it works","title":"Grid representations encode knowledge","text":"Different grid representations encode different facts that can be exploited for performance:\n\nRegularGrid: Knows the grid is axis-aligned and regular, so computing bounding boxes for any region is O(1) — just index into the coordinate vectors.\nCellBasedGrid: Stores corner vertices rather than full polygons. Bounding boxes are computed from the corner points of a region, avoiding polygon traversal.\nExplicitPolygonGrid: The most general case. Must iterate through polygons to compute bounding boxes, but works with any polygon shape.\n\nThe TopDownQuadtreeCursor wraps any of these grid types and provides the tree traversal interface. It tracks which rectangular region of the grid it currently represents and can split that region into four quadrants.","category":"section"},{"location":"how_it_works/#Step-2:-The-dual-tree-query","page":"How it works","title":"Step 2: The dual tree query","text":"Once both grids have tree representations, ConservativeRegridding performs a dual depth-first search. This is the key algorithm that makes conservative regridding tractable for large grids.","category":"section"},{"location":"how_it_works/#The-core-idea","page":"How it works","title":"The core idea","text":"The algorithm walks down both trees simultaneously. At each step, it has a node from the source tree and a node from the destination tree. Each node represents some region of its respective grid and has an extent (bounding box or spherical cap) that encloses all polygons in that region.\n\nThe question at each step is: can any polygon in this source region possibly intersect any polygon in this destination region?\n\nIf the extents don't intersect, the answer is definitively no — and we can prune both branches entirely. This single check eliminates potentially millions of polygon pairs from consideration.\n\nIf the extents do intersect, we recurse: we check each child of the source node against each child of the destination node. This continues until we reach leaf nodes, at which point we record the polygon index pairs for later intersection computation.","category":"section"},{"location":"how_it_works/#Pruning-in-action","page":"How it works","title":"Pruning in action","text":"Consider two 100×100 grids that only overlap in a corner:\n\nSource grid\n┌──────────┐\n│          │\n│          │\n│       ┌──┼──────────┐\n└───────┼──┘          │\n        │↖ overlap    │\n        │             │\n        │  Dest grid  │\n        └─────────────┘\n\nAt the top level, both trees represent their entire grids. The extents intersect (there is overlap), so we recurse.\n\nEach tree splits into four quadrants. The source's top-left, top-right, and bottom-left quadrants don't intersect with any destination quadrant. Only the source's bottom-right quadrant intersects with the destination's top-left quadrant. We've just eliminated 75% of the source grid and 75% of the destination grid from consideration.\n\nThis pruning compounds at each level. If the overlap region is small, the algorithm quickly narrows down to just the relevant cells.","category":"section"},{"location":"how_it_works/#Multithreading","page":"How it works","title":"Multithreading","text":"For large grids, the dual tree query can spawn multiple threads. Once nodes are small enough (determined by an area criterion), each thread independently performs the depth-first search on its subtree pair.\n\nThe result is a list of (source_index, destination_index) pairs — the candidate polygon pairs that might actually intersect.","category":"section"},{"location":"how_it_works/#Step-3:-Computing-intersection-weights-(first-order-conservative)","page":"How it works","title":"Step 3: Computing intersection weights (first-order conservative)","text":"With the candidate pairs identified, we now compute the actual intersection areas. For each pair:\n\nRetrieve the source and destination polygons using getcell\nCompute their geometric intersection\nCalculate the area of that intersection","category":"section"},{"location":"how_it_works/#Manifold-aware-algorithms","page":"How it works","title":"Manifold-aware algorithms","text":"The intersection algorithm depends on the manifold:\n\nPlanar: Uses the Foster-Hormann clipping algorithm, which handles arbitrary (including non-convex) polygons\nSpherical: Uses Sutherland-Hodgman clipping specialized for convex polygons on the unit sphere\n\nAreas are computed in the appropriate geometry — Cartesian area for planar, spherical excess for spherical manifolds.","category":"section"},{"location":"how_it_works/#Parallel-computation","page":"How it works","title":"Parallel computation","text":"The list of candidate pairs is partitioned across threads. Each thread independently computes intersection areas for its partition, then results are merged into a sparse matrix.","category":"section"},{"location":"how_it_works/#The-sparse-matrix","page":"How it works","title":"The sparse matrix","text":"The final output is a sparse matrix A where A[i,j] is the intersection area between destination cell i and source cell j. Most entries are zero (cells don't intersect), which is why sparse storage is essential.\n\nThis matrix, combined with cell areas, is everything needed for conservative regridding:\n\ndestination_field = (A * source_field) ./ destination_areas","category":"section"},{"location":"how_it_works/#Putting-it-together","page":"How it works","title":"Putting it together","text":"Here's the full flow when you call Regridder(dst, src):\n\ndst, src\n    │\n    ▼ treeify()\ndst_tree, src_tree\n    │\n    ▼ dual_depth_first_search()\ncandidate_pairs: [(i₁,j₁), (i₂,j₂), ...]\n    │\n    ▼ compute_intersection_areas() [parallel]\n(row_indices, col_indices, areas)\n    │\n    ▼ sparse()\nintersection_matrix A\n    │\n    ▼ + cell areas\nRegridder","category":"section"},{"location":"how_it_works/#Tips-for-users","page":"How it works","title":"Tips for users","text":"Reuse the Regridder: Building a Regridder is expensive; using it is cheap. If you're regridding multiple fields between the same grids, build the regridder once and reuse it.\n\nLet treeify do its job: In most cases, you can pass your grid directly to Regridder and Trees.treeify will choose a reasonable representation. You as the owner of a grid type only need to implement Trees.treeify correctly.\n\nUnderstand the cost model: The expensive part is usually the polygon intersections, not the tree query. If regridding is slow, it may be because many polygon pairs actually intersect, not because the tree traversal is inefficient.  To be sure of this, you can time how long it takes to run e.g.\n\nimport GeometryOps as GO\n\ntree1 = ...\ntree2 = ...\n\nidxs = Tuple{Int, Int}[]\n@time GO.SpatialTreeInterface.dual_depth_first_search(\n    GO.UnitSpherical._intersects, tree1, tree2\n    ) do i1, i2\n    push!(idxs, (i1, i2))\nend\n\nand see how long that takes (this is singlethreaded).  You can try the same for `ConservativeRegridding.multi","category":"section"}]
}
